<!doctype html>
<html lang="zh-cn">
  <head>
    <title>哈夫曼树及其生成 // 孤星的天空</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.68.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://SolitaryStarSky.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="哈夫曼树及其生成"/>
<meta name="twitter:description" content="什么是哈夫曼树 哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的带权路径长度记为WPL=(W1L1&#43;W2L2&#43;W3L3&#43;&hellip;&#43; WnLn)，N个权值Wi(i=1,2,&hellip;n)构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li(i=1,2,&hellip;n)。可以证明哈夫曼树的WPL是最小的。 构造哈夫曼树的算法如下： 1）对给定的n个权值{W1,W2,W3,&hellip;,Wi,&hellip;,Wn}构成n棵二叉树的初始集合F={T1,T2,T3,&hellip;,Ti,&hellip;, Tn}，其中每棵二叉树Ti中只有一个权值为Wi的根结点，它的左右子树均为空。 2）在F中选取两棵根结点权值最小的树作为新构造的二叉树的左右子树，新二叉树的根结点的权值为其左右子树的根结点的权值之和。 3）从F中删除这两棵树，并把这棵新的二叉树同样以升序排列加入到集合F中。 4）重复2）和3），直到集合F中只有一棵二叉树为止。
 例如，对于4个权值为1、3、5、7的节点构造一棵哈夫曼树，其构造过程如下图所示：  哈夫曼树的算法实现 #include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cfloat&gt;using namespace std; const int n=5; const int m=2*n-1; typedef struct{ float weight; int parent,lchild,rchild; }nodetype; typedef nodetype hftree[m]; hftree T; void huffman(hftree T){ int p1,p2,i,j; float small1,small2; for(i=0;i&lt;n;i&#43;&#43;){ T[i].parent=T[i].lchild=T[i].rchild=-1; } for(i=0;i&lt;n;i&#43;&#43;){ cin&gt;&gt;T[i].weight; } for(i=n;i&lt;m;i&#43;&#43;){ p1=p2=-1; small1=small2=FLT_MAX; for(j=0;j&lt;=i-1;j&#43;&#43;){ if(T[j].parent!=-1)continue; if(T[j].weight&lt;small1){ small2=small1; small1=T[j].weight; p2=p1; p1=j; } else if(T[j].weight&lt;small2){ small2=T[j].weight; p2=j; } } T[p1].parent=T[p2].parent=i; T[i].parent=-1; T[i].lchild=p1; T[i].rchild=p2; T[i].weight=small1&#43;small2; } } 输出哈夫曼树 这里用到了头文件，主要是运用setw()控制一下输出的格式"/>

    <meta property="og:title" content="哈夫曼树及其生成" />
<meta property="og:description" content="什么是哈夫曼树 哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的带权路径长度记为WPL=(W1L1&#43;W2L2&#43;W3L3&#43;&hellip;&#43; WnLn)，N个权值Wi(i=1,2,&hellip;n)构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li(i=1,2,&hellip;n)。可以证明哈夫曼树的WPL是最小的。 构造哈夫曼树的算法如下： 1）对给定的n个权值{W1,W2,W3,&hellip;,Wi,&hellip;,Wn}构成n棵二叉树的初始集合F={T1,T2,T3,&hellip;,Ti,&hellip;, Tn}，其中每棵二叉树Ti中只有一个权值为Wi的根结点，它的左右子树均为空。 2）在F中选取两棵根结点权值最小的树作为新构造的二叉树的左右子树，新二叉树的根结点的权值为其左右子树的根结点的权值之和。 3）从F中删除这两棵树，并把这棵新的二叉树同样以升序排列加入到集合F中。 4）重复2）和3），直到集合F中只有一棵二叉树为止。
 例如，对于4个权值为1、3、5、7的节点构造一棵哈夫曼树，其构造过程如下图所示：  哈夫曼树的算法实现 #include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cfloat&gt;using namespace std; const int n=5; const int m=2*n-1; typedef struct{ float weight; int parent,lchild,rchild; }nodetype; typedef nodetype hftree[m]; hftree T; void huffman(hftree T){ int p1,p2,i,j; float small1,small2; for(i=0;i&lt;n;i&#43;&#43;){ T[i].parent=T[i].lchild=T[i].rchild=-1; } for(i=0;i&lt;n;i&#43;&#43;){ cin&gt;&gt;T[i].weight; } for(i=n;i&lt;m;i&#43;&#43;){ p1=p2=-1; small1=small2=FLT_MAX; for(j=0;j&lt;=i-1;j&#43;&#43;){ if(T[j].parent!=-1)continue; if(T[j].weight&lt;small1){ small2=small1; small1=T[j].weight; p2=p1; p1=j; } else if(T[j].weight&lt;small2){ small2=T[j].weight; p2=j; } } T[p1].parent=T[p2].parent=i; T[i].parent=-1; T[i].lchild=p1; T[i].rchild=p2; T[i].weight=small1&#43;small2; } } 输出哈夫曼树 这里用到了头文件，主要是运用setw()控制一下输出的格式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://SolitaryStarSky.github.io/2019/11/27/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E7%94%9F%E6%88%90/" />
<meta property="article:published_time" content="2019-11-27T15:41:11+00:00" />
<meta property="article:modified_time" content="2019-11-27T15:41:11+00:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://SolitaryStarSky.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>孤星的天空</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">哈夫曼树及其生成</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 27, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div><div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
          <a class="tag" href="https://SolitaryStarSky.github.io/tags/%E6%A0%91/">树</a><a class="tag" href="https://SolitaryStarSky.github.io/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/">哈夫曼树</a></div></div>
    </header>
    <div class="post-content">
      <h2 id="什么是哈夫曼树">什么是哈夫曼树</h2>
<p>哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的带权路径长度记为WPL=(W1<em>L1+W2</em>L2+W3<em>L3+&hellip;+ Wn</em>Ln)，N个权值Wi(i=1,2,&hellip;n)构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li(i=1,2,&hellip;n)。可以证明哈夫曼树的WPL是最小的。
构造哈夫曼树的算法如下：
1）对给定的n个权值{W1,W2,W3,&hellip;,Wi,&hellip;,Wn}构成n棵二叉树的初始集合F={T1,T2,T3,&hellip;,Ti,&hellip;, Tn}，其中每棵二叉树Ti中只有一个权值为Wi的根结点，它的左右子树均为空。
2）在F中选取两棵根结点权值最小的树作为新构造的二叉树的左右子树，新二叉树的根结点的权值为其左右子树的根结点的权值之和。
3）从F中删除这两棵树，并把这棵新的二叉树同样以升序排列加入到集合F中。
4）重复2）和3），直到集合F中只有一棵二叉树为止。</p>
<pre><code>    例如，对于4个权值为1、3、5、7的节点构造一棵哈夫曼树，其构造过程如下图所示：
</code></pre>
<p><img src="/images/3.png" alt=""></p>
<h2 id="哈夫曼树的算法实现">哈夫曼树的算法实现</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iomanip&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;cfloat&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> m<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
    <span style="color:#66d9ef">float</span> weight;
    <span style="color:#66d9ef">int</span> parent,lchild,rchild;
}nodetype;
<span style="color:#66d9ef">typedef</span> nodetype hftree[m];
hftree T;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">huffman</span>(hftree T){
    <span style="color:#66d9ef">int</span> p1,p2,i,j;
    <span style="color:#66d9ef">float</span> small1,small2;
    <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
        T[i].parent<span style="color:#f92672">=</span>T[i].lchild<span style="color:#f92672">=</span>T[i].rchild<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
        cin<span style="color:#f92672">&gt;&gt;</span>T[i].weight;
    }
    <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span>n;i<span style="color:#f92672">&lt;</span>m;i<span style="color:#f92672">++</span>){
        p1<span style="color:#f92672">=</span>p2<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;
        small1<span style="color:#f92672">=</span>small2<span style="color:#f92672">=</span>FLT_MAX;
        <span style="color:#66d9ef">for</span>(j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;=</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">++</span>){
            <span style="color:#66d9ef">if</span>(T[j].parent<span style="color:#f92672">!=-</span><span style="color:#ae81ff">1</span>)<span style="color:#66d9ef">continue</span>;
        	<span style="color:#66d9ef">if</span>(T[j].weight<span style="color:#f92672">&lt;</span>small1){
				small2<span style="color:#f92672">=</span>small1;
				small1<span style="color:#f92672">=</span>T[j].weight;
				p2<span style="color:#f92672">=</span>p1;
				p1<span style="color:#f92672">=</span>j;
			}
			<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(T[j].weight<span style="color:#f92672">&lt;</span>small2){
				small2<span style="color:#f92672">=</span>T[j].weight;
				p2<span style="color:#f92672">=</span>j;
			}
        }
        T[p1].parent<span style="color:#f92672">=</span>T[p2].parent<span style="color:#f92672">=</span>i;
        T[i].parent<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;
        T[i].lchild<span style="color:#f92672">=</span>p1;
        T[i].rchild<span style="color:#f92672">=</span>p2;
        T[i].weight<span style="color:#f92672">=</span>small1<span style="color:#f92672">+</span>small2;
    }
}
</code></pre></div><h2 id="输出哈夫曼树">输出哈夫曼树</h2>
<p>这里用到了<!-- raw HTML omitted -->头文件，主要是运用setw()控制一下输出的格式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print_tree</span>(hftree T){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;index weight parent left right&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;;
		cout <span style="color:#f92672">&lt;&lt;</span> left;
		cout <span style="color:#f92672">&lt;&lt;</span>setw(<span style="color:#ae81ff">5</span>)<span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
		cout <span style="color:#f92672">&lt;&lt;</span> setw(<span style="color:#ae81ff">6</span>) <span style="color:#f92672">&lt;&lt;</span> T[i].weight <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
		cout <span style="color:#f92672">&lt;&lt;</span> setw(<span style="color:#ae81ff">6</span>) <span style="color:#f92672">&lt;&lt;</span> T[i].parent <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
		cout <span style="color:#f92672">&lt;&lt;</span> setw(<span style="color:#ae81ff">6</span>) <span style="color:#f92672">&lt;&lt;</span> T[i].left <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
		cout <span style="color:#f92672">&lt;&lt;</span> setw(<span style="color:#ae81ff">6</span>) <span style="color:#f92672">&lt;&lt;</span> T[i].right <span style="color:#f92672">&lt;&lt;</span> endl;
	}
}

</code></pre></div>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
