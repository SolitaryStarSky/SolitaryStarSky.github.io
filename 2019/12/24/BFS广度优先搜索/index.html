<!doctype html>
<html lang="zh-cn">
  <head>
    <title>BFS————广度优先搜索 // 孤星的天空</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.68.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://SolitaryStarSky.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="BFS————广度优先搜索"/>
<meta name="twitter:description" content="什么是BFS BFS又称为广度优先搜索。举个例子：一群老鼠走迷宫。假设老鼠是无限多的，这群老鼠进去后，在每个路口派出部分老鼠探索所有没走过的路。走某条路的老鼠，如果碰壁无法前行，就停下；如果到达的路口已经有其他老鼠探索过了，也停下。很显然，所有的道路都会走到，而且不会重复。这个思路就是BFS。BFS看起来像“并行计算”，不过，由于程序是单机顺序运行的，所以可以把BFS看成是并行计算的模拟。
如何实现BFS 在具体编程时，一般用队列这种数据结构来具体实现BFS，甚至可以说“BFS=队列”。
代码如下：
#include&lt;iostream&gt;#include&lt;queue&gt;#define CHECK(x,y)(x&gt;=0&amp;&amp;x&lt;=wx&amp;&amp;y&gt;=0&amp;&amp;y&lt;=hy) using namespace std; int wx,hy,num; char room[23][23]; int dir[4][2]={{-1,0},{0,-1},{1,0},{0,1}}; struct node{ int x,y; } void BFS(int dx,int dy){ num=1; queue&lt;node&gt;q; node start,next; start.x=dx; start.y=dy; q.push(start); while(!q.empty()){ next=q.front(); q.pop(); for(int i=0;i&lt;4;i&#43;&#43;){ next.x=start.x&#43;dir[i][0]; next.y=start.y&#43;dir[i][1]; if(CHECK(next.y,next.y)&amp;&amp;room[next.x][next.y]==&#39;.&#39;){ room[next.x][next.y]=&#39;#&#39;; num&#43;&#43;; q.push(next); } } } } int main(){ int dx,dy,x,y; while(cin&gt;&gt;wx&gt;&gt;hy){ if(wx==0&amp;&amp;hy==0)break; for(y=0;y&lt;hy;y&#43;&#43;){ for(x=0;x&lt;wx;x&#43;&#43;){ cin&gt;&gt;room[x][y]; if(room[x][y]==&#39;@&#39;){ dx=x; dy=y; } } } num=0; BFS(dx,dy); cout&lt;&lt;num&lt;&lt;endl; } return 0; } "/>

    <meta property="og:title" content="BFS————广度优先搜索" />
<meta property="og:description" content="什么是BFS BFS又称为广度优先搜索。举个例子：一群老鼠走迷宫。假设老鼠是无限多的，这群老鼠进去后，在每个路口派出部分老鼠探索所有没走过的路。走某条路的老鼠，如果碰壁无法前行，就停下；如果到达的路口已经有其他老鼠探索过了，也停下。很显然，所有的道路都会走到，而且不会重复。这个思路就是BFS。BFS看起来像“并行计算”，不过，由于程序是单机顺序运行的，所以可以把BFS看成是并行计算的模拟。
如何实现BFS 在具体编程时，一般用队列这种数据结构来具体实现BFS，甚至可以说“BFS=队列”。
代码如下：
#include&lt;iostream&gt;#include&lt;queue&gt;#define CHECK(x,y)(x&gt;=0&amp;&amp;x&lt;=wx&amp;&amp;y&gt;=0&amp;&amp;y&lt;=hy) using namespace std; int wx,hy,num; char room[23][23]; int dir[4][2]={{-1,0},{0,-1},{1,0},{0,1}}; struct node{ int x,y; } void BFS(int dx,int dy){ num=1; queue&lt;node&gt;q; node start,next; start.x=dx; start.y=dy; q.push(start); while(!q.empty()){ next=q.front(); q.pop(); for(int i=0;i&lt;4;i&#43;&#43;){ next.x=start.x&#43;dir[i][0]; next.y=start.y&#43;dir[i][1]; if(CHECK(next.y,next.y)&amp;&amp;room[next.x][next.y]==&#39;.&#39;){ room[next.x][next.y]=&#39;#&#39;; num&#43;&#43;; q.push(next); } } } } int main(){ int dx,dy,x,y; while(cin&gt;&gt;wx&gt;&gt;hy){ if(wx==0&amp;&amp;hy==0)break; for(y=0;y&lt;hy;y&#43;&#43;){ for(x=0;x&lt;wx;x&#43;&#43;){ cin&gt;&gt;room[x][y]; if(room[x][y]==&#39;@&#39;){ dx=x; dy=y; } } } num=0; BFS(dx,dy); cout&lt;&lt;num&lt;&lt;endl; } return 0; } " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://SolitaryStarSky.github.io/2019/12/24/BFS%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" />
<meta property="article:published_time" content="2019-12-24T07:57:59+00:00" />
<meta property="article:modified_time" content="2019-12-24T07:57:59+00:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://SolitaryStarSky.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>孤星的天空</h1>
      <p>你若决定灿烂，山无遮，海无拦</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">BFS————广度优先搜索</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Dec 24, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div><div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
          <a class="tag" href="https://SolitaryStarSky.github.io/tags/%E6%90%9C%E7%B4%A2/">搜索</a><a class="tag" href="https://SolitaryStarSky.github.io/tags/BFS/">BFS</a></div></div>
    </header>
    <div class="post-content">
      <h2 id="什么是bfs">什么是BFS</h2>
<p>BFS又称为广度优先搜索。举个例子：一群老鼠走迷宫。假设老鼠是无限多的，这群老鼠进去后，在每个路口派出部分老鼠探索所有没走过的路。走某条路的老鼠，如果碰壁无法前行，就停下；如果到达的路口已经有其他老鼠探索过了，也停下。很显然，所有的道路都会走到，而且不会重复。这个思路就是BFS。BFS看起来像“并行计算”，不过，由于程序是单机顺序运行的，所以可以把BFS看成是并行计算的模拟。</p>
<h2 id="如何实现bfs">如何实现BFS</h2>
<p>在具体编程时，一般用队列这种数据结构来具体实现BFS，甚至可以说“BFS=队列”。</p>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define CHECK(x,y)(x&gt;=0&amp;&amp;x&lt;=wx&amp;&amp;y&gt;=0&amp;&amp;y&lt;=hy)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> wx,hy,num;
<span style="color:#66d9ef">char</span> room[<span style="color:#ae81ff">23</span>][<span style="color:#ae81ff">23</span>];
<span style="color:#66d9ef">int</span> dir[<span style="color:#ae81ff">4</span>][<span style="color:#ae81ff">2</span>]<span style="color:#f92672">=</span>{{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>},{<span style="color:#ae81ff">0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>},{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>},{<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>}};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span>{
    <span style="color:#66d9ef">int</span> x,y;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFS</span>(<span style="color:#66d9ef">int</span> dx,<span style="color:#66d9ef">int</span> dy){
    num<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
    queue<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span>q;
    node start,next;
    start.x<span style="color:#f92672">=</span>dx;
    start.y<span style="color:#f92672">=</span>dy;
    q.push(start);
    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty()){
        next<span style="color:#f92672">=</span>q.front();
        q.pop();
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>;i<span style="color:#f92672">++</span>){
            next.x<span style="color:#f92672">=</span>start.x<span style="color:#f92672">+</span>dir[i][<span style="color:#ae81ff">0</span>];
            next.y<span style="color:#f92672">=</span>start.y<span style="color:#f92672">+</span>dir[i][<span style="color:#ae81ff">1</span>];
            <span style="color:#66d9ef">if</span>(CHECK(next.y,next.y)<span style="color:#f92672">&amp;&amp;</span>room[next.x][next.y]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;.&#39;</span>){
                room[next.x][next.y]<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;#&#39;</span>;
                num<span style="color:#f92672">++</span>;
                q.push(next);
            }
        }
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">int</span> dx,dy,x,y;
    <span style="color:#66d9ef">while</span>(cin<span style="color:#f92672">&gt;&gt;</span>wx<span style="color:#f92672">&gt;&gt;</span>hy){
        <span style="color:#66d9ef">if</span>(wx<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&amp;&amp;</span>hy<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)<span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">for</span>(y<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;y<span style="color:#f92672">&lt;</span>hy;y<span style="color:#f92672">++</span>){
            <span style="color:#66d9ef">for</span>(x<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;x<span style="color:#f92672">&lt;</span>wx;x<span style="color:#f92672">++</span>){
                cin<span style="color:#f92672">&gt;&gt;</span>room[x][y];
                <span style="color:#66d9ef">if</span>(room[x][y]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;@&#39;</span>){
                    dx<span style="color:#f92672">=</span>x;
                    dy<span style="color:#f92672">=</span>y;
                }
            }
        }
        num<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
        BFS(dx,dy);
        cout<span style="color:#f92672">&lt;&lt;</span>num<span style="color:#f92672">&lt;&lt;</span>endl;
    } 
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
